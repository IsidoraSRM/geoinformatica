\documentclass[10pt,aspectratio=169]{beamer}
\usetheme{metropolis}
\usepackage{FiraSans}
\usefonttheme{professionalfonts}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage[spanish]{babel}
\usepackage{tcolorbox}
\usepackage{ragged2e}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{booktabs}
\usepackage{multirow}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{usachblue}{rgb}{0,0.4,0.7}
\definecolor{usachred}{rgb}{0.8,0,0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\tiny,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=3pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\examplebox}[2]{
\begin{tcolorbox}[colframe=usachblue,colback=blue!5,title=#1]
#2
\end{tcolorbox}
}

\setbeamertemplate{footline}{%
  \begin{beamercolorbox}[wd=\paperwidth,sep=2ex]{footline}%
    \usebeamerfont{structure}\textbf{Geoinformática - Clase 4} \hfill Profesor: Francisco Parra O. \hfill \textbf{Semestre 2, 2025}
  \end{beamercolorbox}%
}

\title{Clase 04: Representación de datos geográficos}
\subtitle{Trabajando con R y Python}
\author{Profesor: Francisco Parra O.}
\institute{USACH - Ingeniería Civil en Informática}
\date{\today}

\titlegraphic{%
  \begin{tikzpicture}[overlay, remember picture]
    \node[anchor=north east, yshift=0cm] at (current page.north east) {
      \includegraphics[width=1.5cm]{../../logo.jpg}
    };
  \end{tikzpicture}
}

\begin{document}

\maketitle

\begin{frame}{Agenda}
    \tableofcontents[hideallsubsections]
\end{frame}

\section{Paquete sf en R}

\begin{frame}[fragile]{Paquete sf en R: Introducción}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{¿Qué es sf?}
        \begin{itemize}
            \item Simple Features para R
            \item Estándar OGC/ISO
            \item Reemplazo moderno de sp
            \item Integración con tidyverse
        \end{itemize}
        
        \vspace{0.3cm}
        \textbf{Ventajas:}
        \begin{itemize}
            \item Sintaxis consistente
            \item Compatible con dplyr
            \item Visualización con ggplot2
            \item Manejo eficiente de CRS
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Instalación y carga:}
        \begin{lstlisting}[language=R]
# Instalación
install.packages("sf")

# Carga
library(sf)
library(tidyverse)

# Verificar instalación
sf_extSoftVersion()
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{sf: Estructura de datos}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Objeto sf = data.frame + geometría}
        \begin{lstlisting}[language=R]
# Crear puntos desde coordenadas
df <- data.frame(
  nombre = c("USACH", "UC", "U.Chile"),
  lat = c(-33.449, -33.441, -33.442),
  lon = c(-70.681, -70.640, -70.650)
)

# Convertir a sf
puntos_sf <- st_as_sf(df, 
  coords = c("lon", "lat"),
  crs = 4326)

# Ver estructura
print(puntos_sf)
class(puntos_sf)
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Componentes:}
        \begin{itemize}
            \item \texttt{geometry}: columna especial
            \item Atributos: columnas regulares
            \item CRS: sistema de referencia
            \item Bbox: límites espaciales
        \end{itemize}
        
        \vspace{0.3cm}
        \textbf{Tipos de geometría:}
        \begin{itemize}
            \item POINT
            \item LINESTRING
            \item POLYGON
            \item MULTIPOINT
            \item MULTILINESTRING
            \item MULTIPOLYGON
            \item GEOMETRYCOLLECTION
        \end{itemize}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{sf: Lectura y escritura}
    \begin{lstlisting}[language=R]
# Lectura de archivos espaciales
comunas <- st_read("comunas_chile.shp")
comunas <- st_read("comunas.geojson")
comunas <- st_read("comunas.gpkg")

# Información básica
st_geometry_type(comunas)  # Tipo de geometría
st_crs(comunas)            # Sistema de referencia
st_bbox(comunas)           # Límites espaciales
nrow(comunas)              # Número de features

# Escritura de archivos
st_write(comunas, "output.shp")
st_write(comunas, "output.geojson")
st_write(comunas, "output.gpkg", layer = "comunas")

# Transformación de CRS
comunas_utm <- st_transform(comunas, crs = 32719)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{sf: Operaciones con dplyr}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \begin{lstlisting}[language=R]
# Filter
rm_comunas <- comunas %>%
  filter(region == "RM")

# Select
comunas_min <- comunas %>%
  select(nombre, poblacion, geometry)

# Mutate
comunas <- comunas %>%
  mutate(
    area_km2 = st_area(.) / 1e6,
    densidad = poblacion / area_km2
  )

# Group by + summarize
regiones <- comunas %>%
  group_by(region) %>%
  summarize(
    poblacion_total = sum(poblacion),
    n_comunas = n()
  )
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Operaciones espaciales:}
        \begin{lstlisting}[language=R]
# Buffer
buffer_1km <- st_buffer(puntos_sf, 
                        dist = 1000)

# Intersección
intersec <- st_intersection(a, b)

# Unión
union_all <- st_union(comunas)

# Diferencia
diff <- st_difference(a, b)

# Contains
st_contains(poligono, puntos)

# Within
st_within(puntos, poligono)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{sf: Visualización con ggplot2}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \begin{lstlisting}[language=R]
# Mapa básico
ggplot(comunas) +
  geom_sf() +
  theme_minimal()

# Mapa con colores por variable
ggplot(comunas) +
  geom_sf(aes(fill = poblacion)) +
  scale_fill_viridis_c() +
  labs(title = "Población por comuna",
       fill = "Habitantes") +
  theme_minimal()

# Múltiples capas
ggplot() +
  geom_sf(data = comunas, 
          fill = "lightgray") +
  geom_sf(data = puntos_sf, 
          color = "red", size = 3) +
  coord_sf(crs = 4326)
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \begin{lstlisting}[language=R]
# Mapa interactivo con tmap
library(tmap)
tmap_mode("view")

tm_shape(comunas) +
  tm_polygons("poblacion",
    palette = "Blues",
    title = "Población") +
  tm_shape(puntos_sf) +
  tm_dots(size = 0.1, col = "red")

# Facets espaciales
ggplot(comunas) +
  geom_sf(aes(fill = densidad)) +
  facet_wrap(~region) +
  scale_fill_gradient(
    low = "white", 
    high = "darkred"
  ) +
  theme_minimal()
        \end{lstlisting}
    \end{columns}
\end{frame}

\section{GeoPandas en Python}

\begin{frame}[fragile]{GeoPandas en Python: Introducción}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{¿Qué es GeoPandas?}
        \begin{itemize}
            \item Extensión espacial de pandas
            \item Built on Shapely, Fiona, pyproj
            \item DataFrames con geometría
            \item Análisis espacial simplificado
        \end{itemize}
        
        \vspace{0.3cm}
        \textbf{Ecosistema:}
        \begin{itemize}
            \item \textbf{Shapely}: geometrías
            \item \textbf{Fiona}: I/O de archivos
            \item \textbf{pyproj}: proyecciones
            \item \textbf{rtree}: índices espaciales
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Instalación y carga:}
        \begin{lstlisting}[language=Python]
# Instalación
pip install geopandas
# o con conda
conda install -c conda-forge geopandas

# Importación
import geopandas as gpd
import pandas as pd
from shapely.geometry import Point
import matplotlib.pyplot as plt
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{GeoPandas: GeoDataFrame}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \begin{lstlisting}[language=Python]
# Crear GeoDataFrame desde puntos
df = pd.DataFrame({
    'ciudad': ['Santiago', 'Valparaíso', 
                'Concepción'],
    'lat': [-33.45, -33.04, -36.82],
    'lon': [-70.66, -71.61, -73.04],
    'poblacion': [5614000, 295113, 223574]
})

# Crear geometrías
geometry = [Point(xy) for xy in 
            zip(df['lon'], df['lat'])]

# Crear GeoDataFrame
gdf = gpd.GeoDataFrame(df, 
    geometry=geometry,
    crs='EPSG:4326')

print(gdf.head())
print(gdf.crs)
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Atributos importantes:}
        \begin{lstlisting}[language=Python]
# Geometría activa
gdf.geometry

# Bounds
gdf.bounds
gdf.total_bounds

# Área y longitud
gdf.area  # para polígonos
gdf.length  # para líneas

# Centroide
gdf.centroid

# Tipo de geometría
gdf.geom_type

# Sistema de referencia
gdf.crs
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{GeoPandas: Lectura y escritura}
    \begin{lstlisting}[language=Python]
# Lectura de archivos espaciales
gdf = gpd.read_file("comunas.shp")
gdf = gpd.read_file("data.geojson")
gdf = gpd.read_file("database.gpkg", layer='comunas')

# Lectura con filtro espacial
bbox = (-71, -34, -70, -33)  # minx, miny, maxx, maxy
gdf = gpd.read_file("chile.shp", bbox=bbox)

# Escritura
gdf.to_file("output.shp")
gdf.to_file("output.geojson", driver='GeoJSON')
gdf.to_file("output.gpkg", layer='mi_capa', driver="GPKG")

# Formatos adicionales
gdf.to_csv("datos.csv")  # Sin geometría
gdf.to_parquet("datos.parquet")  # Con geometría (GeoParquet)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{GeoPandas: Operaciones espaciales}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \begin{lstlisting}[language=Python]
# Transformación de CRS
gdf_utm = gdf.to_crs(epsg=32719)
gdf_wgs = gdf.to_crs('EPSG:4326')

# Buffer
gdf['buffer_1km'] = gdf.buffer(1000)

# Operaciones geométricas
union = gdf.unary_union
dissolved = gdf.dissolve(by='region')

# Spatial join
points_in_polys = gpd.sjoin(
    points, polygons, 
    how='inner', 
    predicate='intersects'
)

# Clip
clipped = gpd.clip(gdf, mask)
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \begin{lstlisting}[language=Python]
# Predicados espaciales
gdf.intersects(other)
gdf.contains(point)
gdf.within(polygon)
gdf.crosses(line)
gdf.touches(boundary)
gdf.overlaps(other)

# Operaciones overlay
result = gpd.overlay(
    gdf1, gdf2, 
    how='intersection'
)
# how: 'intersection', 'union',
#      'difference', 
#      'symmetric_difference'

# Distancias
gdf['dist'] = gdf.distance(point)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{GeoPandas: Visualización}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \begin{lstlisting}[language=Python]
# Plot básico
gdf.plot()
plt.show()

# Plot con colores por variable
gdf.plot(column='poblacion', 
         cmap='Blues',
         legend=True,
         figsize=(10, 6))

# Múltiples capas
fig, ax = plt.subplots(figsize=(10, 8))
comunas.plot(ax=ax, color='lightgray',
             edgecolor='black')
ciudades.plot(ax=ax, color='red', 
              markersize=50)
ax.set_title('Mapa de Chile')
plt.show()
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \begin{lstlisting}[language=Python]
# Mapa interactivo con Folium
import folium

# Crear mapa base
m = folium.Map(
    location=[-33.45, -70.66],
    zoom_start=10
)

# Agregar capa
folium.GeoJson(
    gdf.to_json(),
    name='comunas'
).add_to(m)

# Guardar
m.save('mapa.html')

# Con explore (más simple)
gdf.explore(column='poblacion',
           cmap='Blues')
        \end{lstlisting}
    \end{columns}
\end{frame}

\section{Importación y exportación de datos}

\begin{frame}[fragile]{Formatos de datos espaciales}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{Formatos vectoriales:}
        \begin{itemize}
            \item \textbf{Shapefile}: Legacy, múltiples archivos
            \item \textbf{GeoJSON}: JSON, legible
            \item \textbf{GeoPackage}: SQLite, moderno
            \item \textbf{KML/KMZ}: Google Earth
            \item \textbf{GML}: XML-based
            \item \textbf{PostGIS}: PostgreSQL
        \end{itemize}
        
        \vspace{0.3cm}
        \textbf{Formatos raster:}
        \begin{itemize}
            \item \textbf{GeoTIFF}: Con georreferencia
            \item \textbf{NetCDF}: Datos científicos
            \item \textbf{HDF5}: Multidimensional
            \item \textbf{COG}: Cloud Optimized GeoTIFF
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Consideraciones:}
        \begin{tcolorbox}[colframe=usachred,colback=red!5]
        \textbf{Shapefile:}
        \begin{itemize}
            \item Nombres max 10 caracteres
            \item Sin valores NULL
            \item Límite 2GB
        \end{itemize}
        \end{tcolorbox}
        
        \begin{tcolorbox}[colframe=codegreen,colback=green!5]
        \textbf{GeoPackage:}
        \begin{itemize}
            \item Un solo archivo
            \item Múltiples capas
            \item Sin límites de tamaño
            \item Soporte completo SQL
        \end{itemize}
        \end{tcolorbox}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Importación: Diferentes fuentes}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Python - GeoPandas:}
        \begin{lstlisting}[language=Python]
# Desde archivo local
gdf = gpd.read_file("data.shp")

# Desde URL
url = "https://ejemplo.com/data.geojson"
gdf = gpd.read_file(url)

# Desde PostGIS
from sqlalchemy import create_engine
engine = create_engine(
    'postgresql://user:pass@host/db'
)
sql = "SELECT * FROM tabla WHERE region='RM'"
gdf = gpd.read_postgis(sql, engine,
                       geom_col='geom')

# Desde CSV con coordenadas
df = pd.read_csv("puntos.csv")
gdf = gpd.GeoDataFrame(df,
    geometry=gpd.points_from_xy(
        df.lon, df.lat))
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{R - sf:}
        \begin{lstlisting}[language=R]
# Desde archivo local
sf_obj <- st_read("data.shp")

# Desde URL
url <- "https://ejemplo.com/data.json"
sf_obj <- st_read(url)

# Desde PostGIS
library(RPostgreSQL)
con <- dbConnect(PostgreSQL(),
    dbname="db", host="host")
sf_obj <- st_read(con, 
    query = "SELECT * FROM tabla")

# Desde CSV
df <- read.csv("puntos.csv")
sf_obj <- st_as_sf(df,
    coords = c("lon", "lat"),
    crs = 4326)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Exportación: Opciones y optimización}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Python:}
        \begin{lstlisting}[language=Python]
# Shapefile con encoding
gdf.to_file("output.shp", 
           encoding='utf-8')

# GeoJSON simplificado
gdf_simple = gdf.copy()
gdf_simple.geometry = gdf.simplify(
    tolerance=0.001
)
gdf_simple.to_file("simple.geojson",
                  driver='GeoJSON')

# GeoPackage con capas
gdf1.to_file("data.gpkg", layer='capa1',
            driver="GPKG")
gdf2.to_file("data.gpkg", layer='capa2',
            driver="GPKG", mode='a')

# Parquet para big data
gdf.to_parquet("data.parquet")
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{R:}
        \begin{lstlisting}[language=R]
# Opciones de escritura
st_write(sf_obj, "output.shp",
        delete_dsn = TRUE)

# Simplificación
sf_simple <- st_simplify(sf_obj,
    preserveTopology = TRUE,
    dTolerance = 100)
st_write(sf_simple, "simple.json")

# GeoPackage multicapa
st_write(sf1, "data.gpkg",
        layer = "capa1")
st_write(sf2, "data.gpkg",
        layer = "capa2",
        append = TRUE)

# Formato eficiente
library(arrow)
write_parquet(sf_obj, "data.parquet")
        \end{lstlisting}
    \end{columns}
\end{frame}

\section{Estructuras de datos espaciales}

\begin{frame}{Estructuras de datos: Índices espaciales}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{R-tree:}
        \begin{itemize}
            \item Estructura jerárquica
            \item Bounding boxes anidados
            \item Búsqueda O(log n)
            \item Usado en GeoPandas/PostGIS
        \end{itemize}
        
        \vspace{0.3cm}
        
        \begin{tikzpicture}[scale=0.6]
            % Nivel 0 - root
            \draw[thick,blue] (0,0) rectangle (6,4);
            % Nivel 1
            \draw[thick,red] (0.5,0.5) rectangle (2.5,3.5);
            \draw[thick,red] (3.5,0.5) rectangle (5.5,3.5);
            % Nivel 2
            \draw[thick,green] (0.7,0.7) rectangle (1.3,1.3);
            \draw[thick,green] (0.7,2.7) rectangle (1.3,3.3);
            \draw[thick,green] (1.7,0.7) rectangle (2.3,1.3);
            \draw[thick,green] (3.7,0.7) rectangle (4.3,1.3);
            \draw[thick,green] (4.7,2.7) rectangle (5.3,3.3);
        \end{tikzpicture}
        
        \column{0.5\textwidth}
        \textbf{Quadtree:}
        \begin{itemize}
            \item División recursiva en 4
            \item Adaptativo al contenido
            \item Eficiente para puntos
            \item Usado en indexación raster
        \end{itemize}
        
        \vspace{0.3cm}
        
        \begin{tikzpicture}[scale=0.6]
            % Cuadrado principal
            \draw[thick] (0,0) rectangle (4,4);
            % División nivel 1
            \draw (2,0) -- (2,4);
            \draw (0,2) -- (4,2);
            % División nivel 2 (cuadrante superior derecho)
            \draw (3,2) -- (3,4);
            \draw (2,3) -- (4,3);
            % División nivel 3
            \draw (2.5,3) -- (2.5,3.5);
            \draw (2,3.25) -- (3,3.25);
            % Puntos
            \foreach \x/\y in {0.5/0.5,3.5/0.5,0.5/3.5,2.3/3.2,2.7/3.4}
                \fill (\x,\y) circle (0.1);
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Índices espaciales: Implementación}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Python - Uso de índices:}
        \begin{lstlisting}[language=Python]
# GeoPandas usa R-tree automáticamente
gdf.sindex  # Acceso al índice

# Búsqueda eficiente
from shapely.geometry import box
bbox = box(minx, miny, maxx, maxy)

# Candidatos potenciales
possible_matches_index = list(
    gdf.sindex.intersection(bbox.bounds)
)
possible_matches = gdf.iloc[
    possible_matches_index
]

# Verificación precisa
precise_matches = possible_matches[
    possible_matches.intersects(bbox)
]
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{R - Índices espaciales:}
        \begin{lstlisting}[language=R]
# sf usa índices automáticamente
# en operaciones espaciales

# Crear índice explícito
library(sf)
library(s2)

# Para datos planares
sf_use_s2(FALSE)

# Operación con índice
result <- st_intersects(
    puntos, 
    poligonos,
    sparse = TRUE  # matriz sparse
)

# Búsqueda por bbox
bbox <- st_bbox(area_interes)
subset <- st_crop(gdf, bbox)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Topología y relaciones espaciales}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Modelo DE-9IM:}
        \begin{itemize}
            \item Interior (I)
            \item Boundary (B)
            \item Exterior (E)
        \end{itemize}
        
        \begin{table}[h]
        \tiny
        \begin{tabular}{|c|c|c|c|}
        \hline
         & I(B) & B(B) & E(B) \\
        \hline
        I(A) & dim & dim & dim \\
        \hline
        B(A) & dim & dim & dim \\
        \hline
        E(A) & dim & dim & dim \\
        \hline
        \end{tabular}
        \end{table}
        
        \textbf{Predicados espaciales:}
        \begin{itemize}
            \item \texttt{equals}: Misma geometría
            \item \texttt{disjoint}: Sin intersección
            \item \texttt{intersects}: Alguna intersección
            \item \texttt{touches}: Solo boundaries
            \item \texttt{crosses}: Interior cruza
            \item \texttt{within}: A dentro de B
            \item \texttt{contains}: A contiene B
            \item \texttt{overlaps}: Parcial
        \end{itemize}
        
        \column{0.45\textwidth}
        \begin{lstlisting}[language=Python]
# Python - Relaciones
a.intersects(b)
a.contains(b)
a.within(b)
a.touches(b)
a.crosses(b)
a.overlaps(b)
a.equals(b)
a.disjoint(b)

# Matriz DE-9IM
a.relate(b)
# Returns: '212101212'

# Pattern matching
a.relate_pattern(b, 
    'T*F**F***')
        \end{lstlisting}
        
        \begin{lstlisting}[language=R]
# R - Predicados
st_intersects(a, b)
st_contains(a, b)
st_within(a, b)
st_touches(a, b)
st_crosses(a, b)
st_overlaps(a, b)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Validación y reparación de geometrías}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Problemas comunes:}
        \begin{itemize}
            \item Self-intersection
            \item Anillos no cerrados
            \item Orden incorrecto de vértices
            \item Geometrías duplicadas
            \item Slivers (polígonos delgados)
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Python - Validación:}
        \begin{lstlisting}[language=Python]
# Verificar validez
gdf['is_valid'] = gdf.is_valid

# Ver problemas
invalid = gdf[~gdf.is_valid]
print(invalid)

# Explicación del problema
from shapely.validation import explain_validity
for idx, row in invalid.iterrows():
    print(explain_validity(row.geometry))
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Reparación:}
        \begin{lstlisting}[language=Python]
# Python - Reparar
from shapely.geometry import Polygon
from shapely.validation import make_valid

# Método 1: buffer(0)
gdf['geometry'] = gdf.buffer(0)

# Método 2: make_valid
gdf['geometry'] = gdf.apply(
    lambda x: make_valid(x.geometry),
    axis=1
)

# R - Reparación
sf_obj <- st_make_valid(sf_obj)

# Verificar
st_is_valid(sf_obj)

# Simplificar para eliminar slivers
sf_clean <- st_simplify(
    sf_obj,
    dTolerance = 0.001
)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Integración R-Python}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{R desde Python (rpy2):}
        \begin{lstlisting}[language=Python]
import rpy2.robjects as ro
from rpy2.robjects import pandas2ri
pandas2ri.activate()

# Cargar sf en R
ro.r('library(sf)')

# Convertir GeoDataFrame a sf
r_sf = pandas2ri.py2rpy(gdf)

# Ejecutar función R
result = ro.r['st_buffer'](r_sf, 1000)

# Volver a Python
gdf_buffer = pandas2ri.rpy2py(result)
        \end{lstlisting}
        
        \column{0.5\textwidth}
        \textbf{Python desde R (reticulate):}
        \begin{lstlisting}[language=R]
library(reticulate)

# Importar geopandas
gpd <- import("geopandas")

# Leer con geopandas
gdf <- gpd$read_file("data.shp")

# Convertir a sf
sf_obj <- st_as_sf(gdf)

# Operación en R
buffer <- st_buffer(sf_obj, 1000)

# Volver a Python
py_gdf <- r_to_py(buffer)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Optimización y rendimiento}
    \begin{columns}[T]
        \column{0.55\textwidth}
        \textbf{Estrategias de optimización:}
        \begin{itemize}
            \item Usar índices espaciales
            \item Simplificar geometrías
            \item Filtrar por bbox primero
            \item Operaciones vectorizadas
            \item Formato Parquet/Arrow
        \end{itemize}
        
        \vspace{0.3cm}
        
        \begin{lstlisting}[language=Python]
# Simplificar geometrías
gdf_simple = gdf.copy()
gdf_simple.geometry = gdf.simplify(
    tolerance=10,  # metros
    preserve_topology=True
)

# Filtro por bbox antes de operación
bbox = target.total_bounds
candidates = source.cx[
    bbox[0]:bbox[2], bbox[1]:bbox[3]
]
        \end{lstlisting}
        
        \column{0.45\textwidth}
        \textbf{Procesamiento paralelo:}
        \begin{lstlisting}[language=Python]
# Python - Dask-GeoPandas
import dask_geopandas as dgpd

# Particionar datos
ddf = dgpd.from_geopandas(
    gdf, npartitions=4
)

# Operación paralela
result = ddf.map_partitions(
    lambda x: x.buffer(100)
).compute()

# R - parallel processing
library(parallel)
library(foreach)

cl <- makeCluster(4)
result <- foreach(
    i = 1:nrow(sf_obj),
    .packages = 'sf'
) %dopar% {
    st_buffer(sf_obj[i,], 100)
}
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Mejores prácticas}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{Recomendaciones generales:}
        \begin{itemize}
            \item Validar geometrías al importar
            \item Mantener CRS consistente
            \item Usar proyecciones locales para cálculos
            \item Documentar transformaciones
            \item Versionar datos espaciales
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Elección de herramienta:}
        \begin{itemize}
            \item \textbf{R/sf}: Análisis estadístico
            \item \textbf{Python/GeoPandas}: Integración ML
            \item \textbf{PostGIS}: Grandes volúmenes
            \item \textbf{QGIS}: Exploración visual
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Flujo de trabajo típico:}
        \begin{enumerate}
            \item Importar y validar datos
            \item Establecer CRS apropiado
            \item Crear índices espaciales
            \item Realizar análisis
            \item Validar resultados
            \item Exportar en formato óptimo
        \end{enumerate}
        
        \vspace{0.3cm}
        
        \begin{tcolorbox}[colframe=usachblue,colback=blue!5]
        \textbf{Tip:} Siempre trabaja con copias de los datos originales y documenta cada transformación.
        \end{tcolorbox}
    \end{columns}
\end{frame}

\begin{frame}{Recursos y documentación}
    \begin{columns}[T]
        \column{0.5\textwidth}
        \textbf{Documentación oficial:}
        \begin{itemize}
            \item \href{https://r-spatial.github.io/sf/}{sf documentation}
            \item \href{https://geopandas.org}{GeoPandas docs}
            \item \href{https://shapely.readthedocs.io}{Shapely manual}
            \item \href{https://pyproj4.github.io/pyproj/}{pyproj reference}
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Tutoriales recomendados:}
        \begin{itemize}
            \item Geocomputation with R
            \item Python Geospatial Development
            \item PostGIS in Action
            \item Spatial Data Science with R
        \end{itemize}
        
        \column{0.5\textwidth}
        \textbf{Datasets de práctica:}
        \begin{itemize}
            \item Natural Earth Data
            \item OpenStreetMap
            \item GADM boundaries
            \item NASA Earthdata
            \item Copernicus Open Access Hub
        \end{itemize}
        
        \vspace{0.3cm}
        
        \textbf{Comunidades:}
        \begin{itemize}
            \item r-spatial GitHub
            \item GeoPandas Discussions
            \item GIS Stack Exchange
            \item OSGeo mailing lists
        \end{itemize}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Ejercicio integrado}
    \textbf{Análisis de accesibilidad a servicios:}
    \begin{lstlisting}[language=Python]
# 1. Cargar datos
comunas = gpd.read_file('comunas_rm.geojson')
hospitales = gpd.read_file('hospitales.geojson')
poblacion = pd.read_csv('poblacion_comunas.csv')

# 2. Unir datos de población
comunas = comunas.merge(poblacion, on='cod_comuna')

# 3. Calcular distancia al hospital más cercano
from shapely.ops import nearest_points
def distancia_minima(geom, puntos):
    punto_cercano = nearest_points(geom, puntos.unary_union)[1]
    return geom.distance(punto_cercano)

comunas['dist_hospital'] = comunas.geometry.apply(
    lambda x: distancia_minima(x.centroid, hospitales.geometry)
)

# 4. Clasificar accesibilidad y visualizar
comunas['accesibilidad'] = pd.cut(comunas['dist_hospital'], 
                                  bins=[0, 2000, 5000, 10000, float('inf')],
                                  labels=['Muy Alta', 'Alta', 'Media', 'Baja'])
    \end{lstlisting}
\end{frame}

\begin{frame}{Cierre}
    \begin{center}
        \Large{¿Preguntas?}
        
        \vspace{1cm}
        
        \textbf{Próxima clase:} \\
        Análisis espacial y geoestadística
        
        \vspace{1cm}
        
        \textbf{Tarea:} \\
        Implementar pipeline completo de importación, \\
        transformación y exportación con datos reales
    \end{center}
\end{frame}

\end{document}