\documentclass[10pt,aspectratio=169]{beamer}
\usetheme{metropolis}
\usepackage{FiraSans}
\usefonttheme{professionalfonts}

\usepackage{graphicx}
\usepackage{tikz}
\usepackage[spanish]{babel}
\usepackage{tcolorbox}
\usepackage{ragged2e}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{fontawesome5}
\usepackage{amsmath}
\usepackage{amssymb}
\usetikzlibrary{shapes,arrows,positioning,calc,backgrounds,fit,patterns}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{usachblue}{rgb}{0,0.4,0.7}
\definecolor{usachred}{rgb}{0.8,0,0}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\tiny,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=3pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\conceptbox}[2]{
\begin{tcolorbox}[colframe=usachblue,colback=blue!5,title=#1,fonttitle=\bfseries]
#2
\end{tcolorbox}
}

\newcommand{\alertbox}[1]{
\begin{tcolorbox}[colframe=red!70,colback=red!5]
\centering\faExclamationTriangle\space #1
\end{tcolorbox}
}

\newcommand{\tipbox}[1]{
\begin{tcolorbox}[colframe=green!70,colback=green!5]
\centering\faLightbulb\space #1
\end{tcolorbox}
}

\setbeamertemplate{footline}{%
  \begin{beamercolorbox}[wd=\paperwidth,sep=2ex]{footline}%
    \usebeamerfont{structure}\textbf{Geoinformática - Clase 7} \hfill Profesor: Francisco Parra O. \hfill \textbf{Semestre 2, 2025}
  \end{beamercolorbox}%
}

\title{Clase 07: Machine Learning Geoespacial}
\subtitle{Inteligencia Artificial aplicada al Análisis Territorial}
\author{Profesor: Francisco Parra O.}
\institute{USACH - Ingeniería Civil en Informática}
\date{\today}

\titlegraphic{%
  \begin{tikzpicture}[overlay, remember picture]
    \node[anchor=north east, yshift=0cm] at (current page.north east) {
      \includegraphics[width=1.5cm]{../../logo.jpg}
    };
  \end{tikzpicture}
}

\begin{document}

\maketitle

\begin{frame}{Agenda}
    \tableofcontents[hideallsubsections]
\end{frame}

% Sección 1: Introducción
\section{Introducción al ML Geoespacial}

\begin{frame}{¿Por qué Machine Learning en Geografía?}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Desafíos tradicionales:}
        \begin{itemize}
            \item Volumen masivo de datos
            \item Patrones complejos no lineales
            \item Múltiples escalas espaciales
            \item Heterogeneidad espacial
            \item Dimensionalidad alta
        \end{itemize}

        \column{0.5\textwidth}
        \textbf{Oportunidades del ML:}
        \begin{itemize}
            \item Detección automática de patrones
            \item Predicción precisa
            \item Escalabilidad
            \item Manejo de no linealidad
            \item Integración multimodal
        \end{itemize}
    \end{columns}

    \vspace{5mm}
    \begin{center}
        \colorbox{green!20}{
            \parbox{0.9\textwidth}{
                \centering
                \textit{El ML permite extraer conocimiento de datos geoespaciales masivos}
            }
        }
    \end{center}
\end{frame}

\begin{frame}{Particularidades del ML Geoespacial}
    \begin{tikzpicture}[scale=0.8, transform shape]
        % Centro
        \node[circle,draw=usachblue,fill=usachblue!20,minimum size=2cm] (center) at (0,0) {
            \textbf{ML}\\\textbf{Geoespacial}
        };

        % Características alrededor
        \node[rectangle,draw=orange,fill=orange!20,rounded corners] (dep) at (4,2) {
            Dependencia\\Espacial
        };

        \node[rectangle,draw=green,fill=green!20,rounded corners] (het) at (4,-2) {
            Heterogeneidad\\Espacial
        };

        \node[rectangle,draw=red,fill=red!20,rounded corners] (scale) at (-4,2) {
            Efectos de\\Escala
        };

        \node[rectangle,draw=blue,fill=blue!20,rounded corners] (maup) at (-4,-2) {
            MAUP\\Problem
        };

        \node[rectangle,draw=purple,fill=purple!20,rounded corners] (temp) at (0,3.5) {
            Dinámicas\\Temporales
        };

        % Conexiones
        \draw[thick,->] (center) -- (dep);
        \draw[thick,->] (center) -- (het);
        \draw[thick,->] (center) -- (scale);
        \draw[thick,->] (center) -- (maup);
        \draw[thick,->] (center) -- (temp);
    \end{tikzpicture}
\end{frame}

% Sección 2: Datos Geoespaciales para ML
\section{Preparación de Datos Geoespaciales}

\begin{frame}{Tipos de Datos Geoespaciales}
    \begin{columns}
        \column{0.33\textwidth}
        \begin{center}
            \textbf{\faMapMarkedAlt\ Vectoriales}\\
            \vspace{2mm}
            \begin{tikzpicture}[scale=0.5]
                \fill[blue] (0,0) circle (0.2);
                \draw[red,thick] (1,0) -- (2,1) -- (3,0);
                \fill[green!50,draw=green] (4,0) -- (5,1) -- (6,0) -- cycle;
            \end{tikzpicture}
            \begin{itemize}
                \item Puntos
                \item Líneas
                \item Polígonos
                \item Atributos
            \end{itemize}
        \end{center}

        \column{0.33\textwidth}
        \begin{center}
            \textbf{\faImage\ Raster}\\
            \vspace{2mm}
            \begin{tikzpicture}[scale=0.3]
                \foreach \x in {0,...,4} {
                    \foreach \y in {0,...,4} {
                        \pgfmathparse{rnd}
                        \definecolor{randcolor}{rgb}{\pgfmathresult,\pgfmathresult,\pgfmathresult}
                        \fill[randcolor] (\x,\y) rectangle (\x+0.9,\y+0.9);
                    }
                }
            \end{tikzpicture}
            \begin{itemize}
                \item Imágenes satelitales
                \item DEM/DSM
                \item Mapas de calor
                \item Bandas espectrales
            \end{itemize}
        \end{center}

        \column{0.33\textwidth}
        \begin{center}
            \textbf{\faDatabase\ Híbridos}\\
            \vspace{2mm}
            \begin{tikzpicture}[scale=0.5]
                \draw[thick] (0,0) grid (3,3);
                \fill[blue] (0.5,0.5) circle (0.2);
                \fill[blue] (2.5,2.5) circle (0.2);
                \draw[red,thick] (0,2) -- (3,1);
            \end{tikzpicture}
            \begin{itemize}
                \item Nubes de puntos
                \item Grafos espaciales
                \item Trayectorias
                \item Series temporales
            \end{itemize}
        \end{center}
    \end{columns}
\end{frame}

\begin{frame}{Feature Engineering Espacial}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{Características espaciales clave:}
        \begin{enumerate}
            \item \textbf{Coordenadas:} X, Y, Z
            \item \textbf{Distancias:} Euclidiana, Manhattan, Haversine
            \item \textbf{Vecindad:} K-NN, Buffer, Voronoi
            \item \textbf{Contexto:} Estadísticas focales
            \item \textbf{Topología:} Conectividad, adyacencia
            \item \textbf{Morfología:} Forma, área, perímetro
        \end{enumerate}

        \column{0.4\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
# Feature engineering
import geopandas as gpd
from sklearn.neighbors import KNeighborsRegressor

# Distancia a POI
gdf['dist_centro'] = gdf.geometry.distance(centro)

# Densidad vecinal
gdf['densidad_5km'] = gdf.buffer(5000).apply(
    lambda x: gdf[gdf.within(x)].shape[0]
)

# Estadísticas focales
gdf['mean_value_1km'] = focal_statistics(
    gdf, 'value', radius=1000, stat='mean'
)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Manejo de la Autocorrelación Espacial}
    \textbf{Problema:} Los datos espaciales violan el supuesto de independencia

    \vspace{3mm}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Estrategias de mitigación:}
        \begin{itemize}
            \item \faCheckCircle\ Spatial Cross-Validation
            \item \faCheckCircle\ Block sampling
            \item \faCheckCircle\ Spatial features explícitas
            \item \faCheckCircle\ Modelos espacialmente conscientes
        \end{itemize}

        \column{0.5\textwidth}
        \begin{tikzpicture}[scale=0.6]
            % Grid
            \draw[gray!30] (0,0) grid (5,5);

            % Training blocks
            \fill[blue!30] (0,0) rectangle (2,2);
            \fill[blue!30] (3,3) rectangle (5,5);
            \node at (1,1) {Train};
            \node at (4,4) {Train};

            % Test blocks
            \fill[red!30] (3,0) rectangle (5,2);
            \fill[red!30] (0,3) rectangle (2,5);
            \node at (4,1) {Test};
            \node at (1,4) {Test};

            % Buffer
            \draw[thick,dashed] (2.5,0) -- (2.5,5);
            \draw[thick,dashed] (0,2.5) -- (5,2.5);
        \end{tikzpicture}

        \centering
        \small\textit{Spatial CV con buffer zones}
    \end{columns}
\end{frame}

% Sección 3: Algoritmos de ML para Datos Geoespaciales
\section{Algoritmos de Machine Learning}

\begin{frame}{Clasificación de Imágenes Satelitales}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Algoritmos principales:}
        \begin{itemize}
            \item \textbf{Random Forest:} Robusto, interpretable
            \item \textbf{SVM:} Bueno para alta dimensionalidad
            \item \textbf{XGBoost:} Alto rendimiento
            \item \textbf{CNN:} Estado del arte para imágenes
        \end{itemize}

        \vspace{3mm}
        \textbf{Aplicaciones:}
        \begin{itemize}
            \item Uso del suelo
            \item Detección de cambios
            \item Clasificación de cultivos
            \item Análisis urbano
        \end{itemize}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
from sklearn.ensemble import RandomForestClassifier
import rasterio
from rasterio.features import shapes

# Cargar imagen multiespectral
with rasterio.open('sentinel2.tif') as src:
    img = src.read()

# Preparar datos (bandas como features)
X = img.reshape(n_bands, -1).T
y = training_labels.ravel()

# Entrenar clasificador
rf = RandomForestClassifier(n_estimators=100)
rf.fit(X[train_idx], y[train_idx])

# Predicción
y_pred = rf.predict(X)
classified = y_pred.reshape(height, width)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Predicción Espacial con ML}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{Random Forest Espacial}
        \begin{itemize}
            \item Incorpora coordenadas como features
            \item Captura no linealidad espacial
            \item Maneja interacciones complejas
        \end{itemize}

        \vspace{3mm}
        \textbf{Ventajas sobre Kriging:}
        \begin{itemize}
            \item No requiere estacionariedad
            \item Múltiples covariables
            \item Relaciones no lineales
            \item Robustez a outliers
        \end{itemize}

        \column{0.4\textwidth}
        \begin{tikzpicture}[scale=0.7]
            % Árbol simplificado
            \node[circle,draw,fill=blue!20] (root) at (0,3) {$X,Y$};
            \node[circle,draw,fill=green!20] (l1) at (-1.5,2) {$Z_1$};
            \node[circle,draw,fill=green!20] (r1) at (1.5,2) {$Z_2$};
            \node[rectangle,draw,fill=yellow!20] (l2) at (-2,1) {$\hat{y}_1$};
            \node[rectangle,draw,fill=yellow!20] (l3) at (-1,1) {$\hat{y}_2$};
            \node[rectangle,draw,fill=yellow!20] (r2) at (1,1) {$\hat{y}_3$};
            \node[rectangle,draw,fill=yellow!20] (r3) at (2,1) {$\hat{y}_4$};

            \draw[->] (root) -- (l1);
            \draw[->] (root) -- (r1);
            \draw[->] (l1) -- (l2);
            \draw[->] (l1) -- (l3);
            \draw[->] (r1) -- (r2);
            \draw[->] (r1) -- (r3);

            \node at (0,0) {\small RF con features espaciales};
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{Clustering Espacial}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Algoritmos especializados:}

        \vspace{2mm}
        \faMapPin\ \textbf{DBSCAN Espacial}
        \begin{itemize}
            \item Densidad espacial
            \item Formas irregulares
            \item Ruido y outliers
        \end{itemize}

        \vspace{2mm}
        \faChartBar\ \textbf{Regionalization}
        \begin{itemize}
            \item Clusters contiguos
            \item Restricciones espaciales
            \item Homogeneidad interna
        \end{itemize}

        \vspace{2mm}
        \faLayerGroup\ \textbf{Hierarchical Clustering}
        \begin{itemize}
            \item Múltiples escalas
            \item Dendrogramas espaciales
        \end{itemize}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
from sklearn.cluster import DBSCAN
from pysal.lib import weights
from pysal.explore import esda

# DBSCAN espacial
coords = np.column_stack([gdf.x, gdf.y])
db = DBSCAN(eps=0.5, min_samples=5)
gdf['cluster'] = db.fit_predict(coords)

# Regionalización con restricciones
from pysal.lib.region import max_p_regions

w = weights.Queen.from_dataframe(gdf)
attrs = gdf[['income', 'education']].values

gdf['region'] = max_p_regions(
    w, attrs,
    threshold=1000,
    solver='greedy'
)
        \end{lstlisting}
    \end{columns}
\end{frame}

% Sección 4: Deep Learning Geoespacial
\section{Deep Learning para Análisis Territorial}

\begin{frame}{Redes Neuronales Convolucionales (CNN)}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Arquitecturas para imágenes satelitales:}
        \begin{itemize}
            \item \textbf{U-Net:} Segmentación semántica
            \item \textbf{ResNet:} Clasificación profunda
            \item \textbf{YOLO:} Detección de objetos
            \item \textbf{Mask R-CNN:} Segmentación de instancias
        \end{itemize}

        \vspace{3mm}
        \textbf{Aplicaciones:}
        \begin{itemize}
            \item Detección de edificios
            \item Mapeo de carreteras
            \item Análisis de vegetación
            \item Monitoreo de cambios
        \end{itemize}

        \column{0.5\textwidth}
        \begin{tikzpicture}[scale=0.6]
            % Input
            \draw[fill=blue!20] (0,0) rectangle (1,2);
            \node at (0.5,-0.5) {\tiny Input};

            % Conv layers
            \draw[fill=green!20] (1.5,0.25) rectangle (2.5,1.75);
            \draw[fill=green!30] (3,0.5) rectangle (4,1.5);
            \draw[fill=green!40] (4.5,0.75) rectangle (5.5,1.25);

            % Pooling
            \draw[fill=red!20] (6,0.85) rectangle (6.5,1.15);

            % FC
            \draw[fill=yellow!20] (7,0.9) rectangle (7.5,1.1);

            % Output
            \draw[fill=purple!20] (8,0.95) rectangle (8.5,1.05);
            \node at (8.25,-0.5) {\tiny Output};

            % Connections
            \foreach \i in {0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5} {
                \draw[->] (\i,1) -- (\i+0.5,1);
            }

            \node at (4,-1.5) {\small Arquitectura CNN simplificada};
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Segmentación Semántica con U-Net}
    \begin{columns}
        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
import tensorflow as tf
from tensorflow.keras import layers

def unet_model(input_shape):
    inputs = layers.Input(input_shape)

    # Encoder
    c1 = layers.Conv2D(64, 3, activation='relu', padding='same')(inputs)
    p1 = layers.MaxPooling2D(2)(c1)

    c2 = layers.Conv2D(128, 3, activation='relu', padding='same')(p1)
    p2 = layers.MaxPooling2D(2)(c2)

    # Bottleneck
    b = layers.Conv2D(256, 3, activation='relu', padding='same')(p2)

    # Decoder
    u2 = layers.UpSampling2D(2)(b)
    u2 = layers.concatenate([u2, c2])
    c3 = layers.Conv2D(128, 3, activation='relu', padding='same')(u2)

    u1 = layers.UpSampling2D(2)(c3)
    u1 = layers.concatenate([u1, c1])
    c4 = layers.Conv2D(64, 3, activation='relu', padding='same')(u1)

    outputs = layers.Conv2D(n_classes, 1, activation='softmax')(c4)

    return tf.keras.Model(inputs, outputs)
        \end{lstlisting}

        \column{0.5\textwidth}
        \begin{center}
            \textbf{Arquitectura U-Net}
        \end{center}
        \begin{tikzpicture}[scale=0.5]
            % Encoder (izquierda)
            \draw[fill=blue!20] (0,4) rectangle (1,5);
            \draw[fill=blue!30] (0.5,3) rectangle (1.5,4);
            \draw[fill=blue!40] (1,2) rectangle (2,3);
            \draw[fill=blue!50] (1.5,1) rectangle (2.5,2);

            % Bottleneck
            \draw[fill=red!30] (2,0) rectangle (3,1);

            % Decoder (derecha)
            \draw[fill=green!50] (3.5,1) rectangle (4.5,2);
            \draw[fill=green!40] (4,2) rectangle (5,3);
            \draw[fill=green!30] (4.5,3) rectangle (5.5,4);
            \draw[fill=green!20] (5,4) rectangle (6,5);

            % Skip connections
            \draw[dashed,->] (1,4.5) -- (5,4.5);
            \draw[dashed,->] (1.5,3.5) -- (4.5,3.5);
            \draw[dashed,->] (2,2.5) -- (4,2.5);
            \draw[dashed,->] (2.5,1.5) -- (3.5,1.5);

            % Flow
            \draw[thick,->] (0.5,4) -- (1,3.5);
            \draw[thick,->] (1.5,3) -- (1.5,2.5);
            \draw[thick,->] (2,2) -- (2.25,1.5);
            \draw[thick,->] (2.5,1) -- (2.5,0.5);
            \draw[thick,->] (3,0.5) -- (3.5,1);
            \draw[thick,->] (4,1.5) -- (4,2);
            \draw[thick,->] (4.5,2.5) -- (4.5,3);
            \draw[thick,->] (5,3.5) -- (5.5,4);
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{Graph Neural Networks para Datos Espaciales}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{¿Por qué grafos para datos espaciales?}
        \begin{itemize}
            \item Relaciones no euclidianas
            \item Topología compleja
            \item Propagación de información
            \item Efectos de red
        \end{itemize}

        \vspace{3mm}
        \textbf{Aplicaciones:}
        \begin{itemize}
            \item Predicción de tráfico
            \item Análisis de redes urbanas
            \item Difusión espacial
            \item Sistemas de transporte
        \end{itemize}

        \column{0.4\textwidth}
        \begin{tikzpicture}[scale=0.8]
            % Nodos
            \node[circle,draw,fill=blue!30] (1) at (0,2) {1};
            \node[circle,draw,fill=blue!30] (2) at (2,3) {2};
            \node[circle,draw,fill=blue!30] (3) at (3,1) {3};
            \node[circle,draw,fill=blue!30] (4) at (1,0) {4};
            \node[circle,draw,fill=blue!30] (5) at (2.5,2) {5};

            % Edges
            \draw[thick] (1) -- (2);
            \draw[thick] (1) -- (4);
            \draw[thick] (2) -- (3);
            \draw[thick] (2) -- (5);
            \draw[thick] (3) -- (4);
            \draw[thick] (3) -- (5);
            \draw[thick] (4) -- (5);

            % Mensaje
            \draw[red,thick,->] (1) -- (2) node[midway,above] {\tiny msg};
            \draw[red,thick,->] (5) -- (2) node[midway,right] {\tiny msg};

            \node at (1.5,-1) {\small Message Passing};
        \end{tikzpicture}
    \end{columns}
\end{frame}

% Sección 5: Casos de Uso
\section{Casos de Uso y Aplicaciones}

\begin{frame}{Caso 1: Predicción de Precios Inmobiliarios}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Pipeline completo:}
        \begin{enumerate}
            \item \textbf{Datos:}
                \begin{itemize}
                    \item Características propiedades
                    \item POIs cercanos
                    \item Conectividad vial
                    \item Datos socioeconómicos
                \end{itemize}
            \item \textbf{Features espaciales:}
                \begin{itemize}
                    \item Distancia a metro
                    \item Densidad comercial
                    \item Índice de vegetación
                \end{itemize}
            \item \textbf{Modelo:} XGBoost + features espaciales
            \item \textbf{Validación:} Spatial CV
        \end{enumerate}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
# Pipeline de predicción
import xgboost as xgb
from sklearn.model_selection import GridSearchCV

# Feature engineering espacial
gdf['dist_metro'] = gdf.geometry.apply(
    lambda x: metro_stations.distance(x).min()
)
gdf['comercios_500m'] = gdf.buffer(500).apply(
    lambda x: comercios[comercios.within(x)].shape[0]
)

# Modelo con búsqueda de hiperparámetros
param_grid = {
    'max_depth': [3, 5, 7],
    'n_estimators': [100, 200, 300],
    'learning_rate': [0.01, 0.1, 0.3]
}

xgb_model = xgb.XGBRegressor()
spatial_cv = SpatialKFold(n_splits=5)

grid = GridSearchCV(xgb_model, param_grid,
                   cv=spatial_cv)
grid.fit(X_train, y_train)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Caso 2: Detección de Cambios en Uso del Suelo}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{Arquitectura CNN para change detection:}

        \vspace{2mm}
        \begin{tikzpicture}[scale=0.5]
            % T1 image
            \draw[fill=blue!20] (0,3) rectangle (2,5);
            \node at (1,2.5) {\tiny T1};

            % T2 image
            \draw[fill=red!20] (0,0) rectangle (2,2);
            \node at (1,-0.5) {\tiny T2};

            % Concatenation
            \draw[fill=purple!20] (3,1) rectangle (4,4);
            \draw[->] (2,4) -- (3,3);
            \draw[->] (2,1) -- (3,2);

            % CNN layers
            \draw[fill=green!20] (4.5,1.5) rectangle (5.5,3.5);
            \draw[fill=green!30] (6,1.75) rectangle (7,3.25);
            \draw[fill=green!40] (7.5,2) rectangle (8.5,3);

            % Output
            \draw[fill=yellow!20] (9,2.25) rectangle (10,2.75);
            \node at (9.5,1.5) {\tiny Change Map};

            % Connections
            \foreach \i in {4,5.5,7,8.5} {
                \draw[->] (\i,2.5) -- (\i+0.5,2.5);
            }
        \end{tikzpicture}

        \vspace{3mm}
        \textbf{Métricas de evaluación:}
        \begin{itemize}
            \item Overall Accuracy
            \item Kappa coefficient
            \item F1-score por clase
            \item IoU (Intersection over Union)
        \end{itemize}

        \column{0.4\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
# Detección de cambios
def change_detection_model():
    input_t1 = Input((256, 256, 4))
    input_t2 = Input((256, 256, 4))

    # Feature extraction
    features_t1 = vgg16_encoder(input_t1)
    features_t2 = vgg16_encoder(input_t2)

    # Difference learning
    diff = layers.subtract([features_t1, features_t2])

    # Decoder
    x = decoder_block(diff)

    # Output: binary change map
    output = Conv2D(1, 1, activation='sigmoid')(x)

    return Model([input_t1, input_t2], output)

# Training con data augmentation espacial
datagen = SpatialAugmentation(
    rotation_range=20,
    horizontal_flip=True,
    vertical_flip=True
)
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Caso 3: Predicción de Demanda de Transporte}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{LSTM Espaciotemporal:}
        \begin{itemize}
            \item Captura patrones temporales
            \item Considera dependencia espacial
            \item Maneja múltiples series
        \end{itemize}

        \vspace{3mm}
        \begin{tikzpicture}[scale=0.6]
            % Time steps
            \foreach \t in {0,1,2} {
                \draw[fill=blue!20] (\t*2,0) rectangle (\t*2+1,1);
                \node at (\t*2+0.5,-0.5) {\tiny t-\t};
            }

            % LSTM cells
            \foreach \t in {0,1,2} {
                \draw[fill=green!30] (\t*2,1.5) rectangle (\t*2+1,2.5);
                \node at (\t*2+0.5,2) {\tiny LSTM};
                \draw[->] (\t*2+0.5,1) -- (\t*2+0.5,1.5);
            }

            % Connections
            \draw[->] (0.5,2.5) -- (2.5,2.5);
            \draw[->] (2.5,2.5) -- (4.5,2.5);

            % Output
            \draw[fill=red!20] (5,3) rectangle (6,4);
            \draw[->] (5,2.5) -- (5.5,3);
            \node at (5.5,4.5) {\tiny Predicción};
        \end{tikzpicture}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.models import Sequential

# Preparar datos espaciotemporales
def prepare_st_data(gdf, time_steps=24):
    X, y = [], []
    for location in gdf.location_id.unique():
        loc_data = gdf[gdf.location_id == location]

        for i in range(len(loc_data) - time_steps):
            X.append(loc_data.iloc[i:i+time_steps].values)
            y.append(loc_data.iloc[i+time_steps].demand)

    return np.array(X), np.array(y)

# Modelo LSTM
model = Sequential([
    LSTM(50, return_sequences=True,
         input_shape=(time_steps, n_features)),
    LSTM(50),
    Dense(25, activation='relu'),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')
        \end{lstlisting}
    \end{columns}
\end{frame}

% Sección 6: Herramientas y Frameworks
\section{Herramientas y Frameworks}

\begin{frame}{Ecosistema de Herramientas}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{\faPython\ Python Stack:}
        \begin{itemize}
            \item \textbf{Scikit-learn:} ML clásico
            \item \textbf{TensorFlow/PyTorch:} Deep Learning
            \item \textbf{GeoPandas:} Datos vectoriales
            \item \textbf{Rasterio:} Datos raster
            \item \textbf{PySAL:} Análisis espacial
            \item \textbf{EarthEngine:} Big data satelital
        \end{itemize}

        \vspace{3mm}
        \textbf{\faCloud\ Cloud Platforms:}
        \begin{itemize}
            \item Google Earth Engine
            \item AWS SageMaker
            \item Azure ML
            \item Planetary Computer
        \end{itemize}

        \column{0.5\textwidth}
        \textbf{\faCode\ Frameworks especializados:}

        \vspace{2mm}
        \colorbox{blue!20}{\textbf{TorchGeo}}
        \begin{itemize}
            \item Datasets geoespaciales
            \item Modelos preentrenados
            \item Augmentation espacial
        \end{itemize}

        \vspace{2mm}
        \colorbox{green!20}{\textbf{Raster Vision}}
        \begin{itemize}
            \item Pipeline completo
            \item Chips generation
            \item Model zoo
        \end{itemize}

        \vspace{2mm}
        \colorbox{red!20}{\textbf{GDAL/OGR}}
        \begin{itemize}
            \item Procesamiento raster/vector
            \item Transformaciones CRS
            \item I/O formatos
        \end{itemize}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Pipeline Completo con TorchGeo}
\begin{lstlisting}[language=Python,basicstyle=\tiny]
import torch
from torchgeo.datasets import EuroSAT
from torchgeo.models import ResNet50
from torchgeo.samplers import RandomGeoSampler
from torch.utils.data import DataLoader

# Dataset geoespacial
dataset = EuroSAT(root='data/', download=True)

# Sampler espacial
sampler = RandomGeoSampler(
    dataset,
    size=256,
    length=10000,
    roi=region_of_interest
)

# DataLoader
dataloader = DataLoader(
    dataset,
    batch_size=32,
    sampler=sampler,
    collate_fn=stack_samples
)

# Modelo preentrenado
model = ResNet50(weights='eurosat', num_classes=10)

# Fine-tuning
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
criterion = torch.nn.CrossEntropyLoss()

for epoch in range(num_epochs):
    for batch in dataloader:
        images = batch['image']
        labels = batch['label']

        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
\end{lstlisting}
\end{frame}

% Sección 7: Mejores Prácticas
\section{Mejores Prácticas y Consideraciones}

\begin{frame}{Validación en ML Geoespacial}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{\faExclamationTriangle\ Errores comunes:}
        \begin{itemize}
            \item Random split ignora autocorrelación
            \item Data leakage espacial
            \item Overfitting a patrones locales
            \item Ignorar efectos de escala
        \end{itemize}

        \vspace{3mm}
        \textbf{\faCheckCircle\ Buenas prácticas:}
        \begin{itemize}
            \item Spatial Cross-Validation
            \item Leave-One-Region-Out
            \item Temporal + Spatial splits
            \item Métricas espacialmente explícitas
        \end{itemize}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
from sklearn.model_selection import BaseCrossValidator

class SpatialKFold(BaseCrossValidator):
    def __init__(self, n_splits=5, buffer_size=1000):
        self.n_splits = n_splits
        self.buffer_size = buffer_size

    def split(self, X, y=None, groups=None):
        # Crear clusters espaciales
        kmeans = KMeans(n_clusters=self.n_splits)
        clusters = kmeans.fit_predict(X[['x', 'y']])

        for i in range(self.n_splits):
            # Test indices
            test_idx = np.where(clusters == i)[0]

            # Train indices (con buffer)
            test_points = X.iloc[test_idx].geometry
            buffer = test_points.buffer(self.buffer_size)

            train_mask = ~X.geometry.within(buffer.unary_union)
            train_idx = np.where(train_mask)[0]

            yield train_idx, test_idx
        \end{lstlisting}
    \end{columns}
\end{frame}

\begin{frame}{Interpretabilidad y Explicabilidad}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{Técnicas de interpretación:}

        \vspace{2mm}
        \faChartLine\ \textbf{Feature Importance}
        \begin{itemize}
            \item Permutation importance
            \item SHAP values espaciales
            \item Partial dependence plots
        \end{itemize}

        \vspace{2mm}
        \faMap\ \textbf{Mapas de explicación}
        \begin{itemize}
            \item Grad-CAM para CNNs
            \item Attention maps
            \item Local interpretations
        \end{itemize}

        \vspace{2mm}
        \faSearch\ \textbf{Análisis de errores}
        \begin{itemize}
            \item Mapeo de residuos
            \item Patrones espaciales de error
            \item Análisis por región
        \end{itemize}

        \column{0.4\textwidth}
        \begin{tikzpicture}[scale=0.7]
            % Feature importance bar chart
            \draw[->] (0,0) -- (0,3);
            \draw[->] (0,0) -- (3,0);

            \draw[fill=blue!40] (0.3,0) rectangle (0.7,2.5);
            \draw[fill=green!40] (0.9,0) rectangle (1.3,2.0);
            \draw[fill=red!40] (1.5,0) rectangle (1.9,1.5);
            \draw[fill=yellow!40] (2.1,0) rectangle (2.5,1.0);

            \node[rotate=90] at (-0.5,1.5) {\tiny Importance};
            \node at (0.5,-0.3) {\tiny F1};
            \node at (1.1,-0.3) {\tiny F2};
            \node at (1.7,-0.3) {\tiny F3};
            \node at (2.3,-0.3) {\tiny F4};

            \node at (1.5,-1) {\small Feature Importance};
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{Escalabilidad y Big Data}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{Estrategias de escalamiento:}
        \begin{itemize}
            \item \textbf{Dask:} Paralelización local
            \item \textbf{Spark:} Procesamiento distribuido
            \item \textbf{Cloud computing:} GEE, AWS
            \item \textbf{GPU acceleration:} RAPIDS
        \end{itemize}

        \vspace{3mm}
        \textbf{Optimizaciones:}
        \begin{itemize}
            \item Tile-based processing
            \item Lazy evaluation
            \item Data pyramids
            \item COG (Cloud Optimized GeoTIFF)
        \end{itemize}

        \column{0.5\textwidth}
        \begin{lstlisting}[language=Python,basicstyle=\tiny]
import dask.dataframe as dd
import dask_geopandas as dgpd
from dask.distributed import Client

# Cliente Dask distribuido
client = Client('scheduler-address:8786')

# GeoDataFrame distribuido
ddf = dgpd.read_parquet('geodata/*.parquet')

# Operaciones lazy
ddf['buffer_1km'] = ddf.geometry.buffer(1000)
ddf['area'] = ddf.buffer_1km.area

# Feature engineering paralelo
def compute_spatial_features(partition):
    # Operaciones por partición
    partition['neighbor_count'] = ...
    return partition

ddf = ddf.map_partitions(compute_spatial_features)

# Computar cuando sea necesario
result = ddf.compute()
        \end{lstlisting}
    \end{columns}
\end{frame}

% Sección 8: Tendencias y Futuro
\section{Tendencias y Futuro}

\begin{frame}{Tendencias Emergentes}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{\faRocket\ Nuevas direcciones:}

        \vspace{2mm}
        \colorbox{blue!20}{\textbf{Foundation Models}}
        \begin{itemize}
            \item Modelos preentrenados masivos
            \item Transfer learning geoespacial
            \item Few-shot learning
        \end{itemize}

        \vspace{2mm}
        \colorbox{green!20}{\textbf{AutoML Espacial}}
        \begin{itemize}
            \item Optimización automática
            \item Neural Architecture Search
            \item Feature engineering automático
        \end{itemize}

        \vspace{2mm}
        \colorbox{red!20}{\textbf{Física-informada}}
        \begin{itemize}
            \item Physics-informed neural networks
            \item Restricciones espaciales
            \item Modelos híbridos
        \end{itemize}

        \column{0.5\textwidth}
        \textbf{\faBrain\ IA Generativa Espacial:}

        \vspace{3mm}
        \begin{tikzpicture}[scale=0.7]
            % Input noise
            \draw[fill=gray!20] (0,1) rectangle (1,2);
            \node at (0.5,0.5) {\tiny Noise};

            % Generator
            \draw[fill=blue!30] (2,0.5) rectangle (3.5,2.5);
            \node at (2.75,1.5) {\tiny GAN};

            % Generated map
            \draw[fill=green!20] (4.5,1) rectangle (5.5,2);
            \node at (5,0.5) {\tiny Map};

            % Discriminator
            \draw[fill=red!30] (2,3) rectangle (3.5,4);
            \node at (2.75,3.5) {\tiny Disc};

            % Real map
            \draw[fill=yellow!20] (0,3.5) rectangle (1,4.5);
            \node at (0.5,3) {\tiny Real};

            % Arrows
            \draw[->] (1,1.5) -- (2,1.5);
            \draw[->] (3.5,1.5) -- (4.5,1.5);
            \draw[->] (5,2) -- (3.5,3.5);
            \draw[->] (1,4) -- (2,3.5);
        \end{tikzpicture}

        \vspace{3mm}
        Aplicaciones:
        \begin{itemize}
            \item Síntesis de mapas
            \item Super-resolución satelital
            \item Simulación urbana
        \end{itemize}
    \end{columns}
\end{frame}

\begin{frame}{Desafíos y Oportunidades}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{\faExclamationCircle\ Desafíos actuales:}
        \begin{itemize}
            \item Datos etiquetados escasos
            \item Transferibilidad geográfica
            \item Sesgo espacial
            \item Incertidumbre cuantificación
            \item Cambio de distribución
        \end{itemize}

        \vspace{3mm}
        \textbf{\faLightbulb\ Oportunidades:}
        \begin{itemize}
            \item Integración multimodal
            \item Digital twins urbanos
            \item Monitoreo en tiempo real
            \item Predicción de riesgos
            \item Planificación adaptativa
        \end{itemize}

        \column{0.5\textwidth}
        \begin{center}
            \textbf{Ciclo virtuoso del ML Geoespacial}
        \end{center}
        \begin{tikzpicture}[scale=0.7]
            % Nodes
            \node[circle,draw,fill=blue!20] (data) at (0,2) {Datos};
            \node[circle,draw,fill=green!20] (model) at (2,3.5) {Modelo};
            \node[circle,draw,fill=red!20] (pred) at (4,2) {Predicción};
            \node[circle,draw,fill=yellow!20] (action) at (2,0.5) {Acción};

            % Arrows
            \draw[thick,->] (data) -- (model);
            \draw[thick,->] (model) -- (pred);
            \draw[thick,->] (pred) -- (action);
            \draw[thick,->] (action) -- (data);

            % Labels
            \node at (1,3) {\tiny Train};
            \node at (3,3) {\tiny Infer};
            \node at (3,1) {\tiny Deploy};
            \node at (1,1) {\tiny Collect};
        \end{tikzpicture}
    \end{columns}
\end{frame}

% Resumen
\begin{frame}{Resumen y Conclusiones}
    \begin{columns}
        \column{0.6\textwidth}
        \textbf{Puntos clave:}
        \begin{itemize}
            \item ML transforma el análisis geoespacial
            \item Considerar siempre dependencia espacial
            \item Validación espacial es crítica
            \item Deep Learning abre nuevas posibilidades
            \item Interpretabilidad sigue siendo esencial
        \end{itemize}

        \vspace{3mm}
        \textbf{Para profundizar:}
        \begin{itemize}
            \item Documentación TorchGeo
            \item Tutoriales Google Earth Engine
            \item Papers en IGARSS, NeurIPS
            \item Cursos de especialización online
        \end{itemize}

        \column{0.4\textwidth}
        \begin{center}
            \colorbox{usachblue!20}{
                \parbox{0.9\columnwidth}{
                    \centering
                    \textbf{El futuro del análisis territorial es inteligente, automatizado y espacialmente consciente}
                }
            }
        \end{center}

        \vspace{5mm}
        \begin{center}
            \faEnvelope\ francisco.parra.o@usach.cl\\
            \faGithub\ github.com/franciscoparrao
        \end{center}
    \end{columns}
\end{frame}

% Próximos pasos
\begin{frame}{Próximos Pasos}
    \begin{columns}
        \column{0.5\textwidth}
        \textbf{\faCode\ Ejercicios prácticos:}
        \begin{enumerate}
            \item Clasificación de uso del suelo con RF
            \item Segmentación de edificios con U-Net
            \item Predicción espacial con XGBoost
            \item Clustering espacial con DBSCAN
        \end{enumerate}

        \vspace{3mm}
        \textbf{\faBookOpen\ Lecturas recomendadas:}
        \begin{itemize}
            \item "Deep Learning for the Earth Sciences"
            \item "Spatial Data Science with Python"
            \item Papers de CVPR Earth Vision
        \end{itemize}

        \column{0.5\textwidth}
        \textbf{\faProjectDiagram\ Proyecto final:}

        \vspace{2mm}
        \colorbox{green!20}{
            \parbox{0.9\columnwidth}{
                Desarrollar pipeline completo de ML para problema geoespacial real:
                \begin{itemize}
                    \item Definir problema
                    \item Preparar datos
                    \item Entrenar modelo
                    \item Validar espacialmente
                    \item Interpretar resultados
                    \item Desplegar solución
                \end{itemize}
            }
        }
    \end{columns}
\end{frame}

\end{document}